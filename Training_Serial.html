<!DOCTYPE html>

<html lang="en">

<head>
  <title>Training Serial Dots</title>
  <script src="jspsych-6.0.4/jspsych.js"></script>
  <script src="jspsych-6.0.4/plugins/jspsych-instructions.js"></script>
  <script src="jspsych-6.0.4/plugins/jspsych-fullscreen.js"></script>
  <!-- custom scripts -->
  <script src="jspsych-6.0.4/plugins/custom-manual-inhibition-serial.js"></script>
  <script src="jspsych-6.0.4/plugins/custom-html-button-response-conditional.js"></script>
  <link href="styles.css" rel="stylesheet" type="text/css">
  <script src="objects.js"></script>
  <script type= "text/javascript" src="loops.js"></script>
  <script src="common_vars.js"></script>
  <!-- jatos import -->
  <script src="jatos.js"></script>
  <!-- css import -->
  <link rel="stylesheet" type="text/css" href="jspsych-6.0.4/css/jspsych.css"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
</head>

  <body bgcolor='gray'>
  <script>

    // salute the hacker
    console.log("There's only two type of people in this world: Those who can extrapolate from incomplete data.");

    // this training trial is basically like the experiment, but shorter

    // define parameter values for the experiment
    let nTrials = 1; // number of trials per condition
    let trialDuration = 1500; // duration of the trial
    // for this design, we will create n even time windows between 0 up to the duration of the experiment.
    // we will sample nTrials random trials in each of these time windows.
    // This ensures a random distribution that samples across the entire range from 0 up to the trial duration
    // and avoids clusters appearing by chance.
    let maxFlashTime = trialDuration; // maximum time after which a flash is shown in ms
    let twSize = 100; // the size of the time windows
    let flashDuration = 30; // how long the flash will be on the screen in ms
    let waitAfter = 500; // how long we will wait at the end of the trial in ms

    let timelineVariables = Serial_loop(nTrials, maxFlashTime, twSize);

    // define the main trial for the experiment
    let trial = {
      type: 'manual-inhibition-serial', // calls the custom plugin
      buttonsVisible: visibleButtons, // the visible buttons are an array of dots
      buttonsInvisible: invisibleButtons, // the invisible buttons are an array of dots
      flashUp: flashUpVisible, // the upper part of the white flash
      flashDown:flashDownVisible, // the lower part of the white flash
      flashTime: jsPsych.timelineVariable('flashTime'), // the time when the flash appears between 0 ms and the trial duration
      flashDuration: flashDuration, // the time the flash is visible in ms
      trialDuration: trialDuration, // the trial duration after the first point was touched
      waitAfter: waitAfter, // how long to wait after the trial ended
      runTrial: function(){
        // in this function, we define if we want to run this trial or not
        // get the id of the current trial
        let id_here = jsPsych.timelineVariable('trialID', true);
        // if there are any values in the repeat trial array
        if (repeat_trials.length > 0) {
          // run the trial if the value is inside the array
          repeat = repeat_trials.includes(id_here);
        } else {
          // this is the first round, we run every trial
          repeat = true;
        }
        return repeat;
        },
      data:{
        // assign relevant data
        // with true, these functions evaluate immediately
        test_part: 'Serial-Inhibition', // the part of the experiment
        flashTime: jsPsych.timelineVariable('flashTime'),  // the time when a flash was shown
        trialID: jsPsych.timelineVariable('trialID'), // the id of the trial
      },
      on_finish:  function(data){
        // evaluate if the there were any mistakes and if the trial need repetition
        orderResponse = data.orderResponse; // were the answers given in order
        lateResponse = data.lateResponse; // was the response fast enough
        // if out of order or late response, create new T object and push it to repeat_IDs
        if (data.trialShown) {
          // evaluate only for trials that were shown
          if (lateResponse || !orderResponse) {
            // if there was any error
            // get the trial ID
            T = jsPsych.timelineVariable("trialID", true);
            // and save it
            repeat_IDs.push(T);
          }
        }
      },
    };

    // display feedback
    let feedback = {
      type: 'html-button-response-conditional',
      trialID: jsPsych.timelineVariable('trialID'),
      stimulus: function () {
        // evaluate which feedback should be shown
        if (lateResponse){
          return "<p>Too slow</p>"
        }else if (orderResponse) {
          return "<p>Well Done.</p>"
        } else {
          return "<p>Please follow the order.</p>"
        }
      },
      post_trial_gap: 0, // needs to be zero to avoid waiting times when the trial is skipped
      choices: [''], // don't display choices
      button_html: '', // don't display buttons
      trial_duration: 1500, // display the feedback for 1500 ms
      runTrial: function(){return repeat}, // evaluate if the trial should run or not
      data:{
          test_part: 'feedback',
      },
    };

    // define a training procedure
    let test_procedure = {
      timeline: [trial, feedback], // one trial and one feedback will be repeated after each other
      timeline_variables: timelineVariables, // our design structure provides the timeline variables
      repetitions: 1, // our design structure is repeated once
      randomize_order: true, // our design structure will be repeated in a random order
      // this function evaluates if we want to repeat the loop
      // if it evaluates to true, we repeat the full design matrix
      loop_function: function(){
          // save the IDs to be repeated in a new variable
          repeat_trials = repeat_IDs;
          // check if there are any IDs to repeat
          let eval_loop = repeat_IDs.length > 0;
          // reset the repetition array to empty
          repeat_IDs = [];
          // return true or false
          return eval_loop
      },
    };
    timeline.push(test_procedure);

    // let them know that the training is over
    let end_instructions = {
        type: 'instructions',
        pages: ["<p>That's the end of the training block.</p>" +
        "<p>Let's start the experiment.</p>"],
        show_clickable_nav: true,
        button_label_next: 'Ok. Continue >',
        post_trial_gap: 200,
        data: {
            test_part: 'intro',
        }
    };
    timeline.push(end_instructions);


    jatos.onLoad(function () {
      jsPsych.data.addProperties({
        subject: jatos.workerId,
        screenWidth: screen.width,
        screenHeight: screen.height,
        userInfo: navigator.userAgent,
        platform: navigator.platform,
        scrPixDepth: screen.pixelDepth,
        scrColDepth : screen.colorDepth,
        scrOrientation: ori,
        scrResolution: window.devicePixelRatio,
        component: 'Training_Serial',
      });

      jsPsych.init({
        timeline: timeline,
        fullscreen: true,
        on_finish: function() {
          let resultJson = jsPsych.data.get().json();
          jatos.submitResultData(resultJson, jatos.startNextComponent);
        }
      });
    });

  </script>
  </body>
</html>
