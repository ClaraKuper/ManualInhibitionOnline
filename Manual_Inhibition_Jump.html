<!doctype html>
<!-- Example taken from http://www.jspsych.org/tutorials/rt-task/ and adapted for the use with JATOS -->
<html lang="en">

<head>
    <title>Experiment Block Jumping Dots</title>
    <!-- If you use an older version of JATOS (< 3.3.1) you have to use absolutes path for you assets and jatos.js-->
    <script src="jspsych-6.0.4/jspsych.js"></script>
    <script src="jspsych-6.0.4/plugins/jspsych-fullscreen.js"></script>
    <!-- custom scripts -->
    <script src="jspsych-6.0.4/plugins/custom-html-button-response-conditional.js"></script>
    <script src="jspsych-6.0.4/plugins/custom-manual-inhibition-jump.js"></script>
    <!-- jatos import -->
    <script src="jatos.js"></script>
    <!-- css import -->
    <link href="jspsych-6.0.4/css/jspsych.css" rel="stylesheet" type="text/css">
    <style>
        p {
            font-size: 1em;
        }
        dot {
            position:absolute;
            display:inline;
            top: 50%; /* position in center of screen */
            height: 50px; /* size */
            width: 50px; /* size */
            background-color: #000000; /* color to black */
            border-radius: 50%; /* makes the square a dot */
            margin-top: -25px; /* makes sure the dot is centered */
            margin-left: -25px; /* makes sure the dot is centered */
            -webkit-touch-callout: none; /* prevent marking on iOS Safari */
            -webkit-user-select: none; /* prevent marking on Safari */
        }
    </style>
    <!-- meta prevents zooming in -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >

</head>

<body bgcolor='gray'>
    <script>

        // salute the hacker
        console.log("Welcome to the show!");

        // define parameter values for the experiment:
        let nTrials = 10; // the number of trials
        let cFlash = [0,1]; // the flash conditions
        let cJump = [0,1]; // the jump conditions
        let cInwards = [0,1]; // inward/not condition
        let cPosition = ['l','r']; // the position condition
        let fixTime = 1000; // how long the central point is maximally touched before the trial starts
        let flashTime = 250; // the longest time till the flash occurs after trial start
        let trialDur = 1000; // the duration of the experiment (without fixation time)
        let waitAfter = 500; // time to wait after each trial
        let flashDur = 30; // how long to display the flash in ms

        /* create timeline */
        let timeline = []; // timeline to run on jsPsych.init
        let test_stimuli = []; // the design structure, stimulus values for each trial
        let repeat_IDs = []; // a list of all IDs that have to be repeated
        let repeat_trials = []; // gets assigned to repeat_IDs at the end of each run

        // boolean checks
        let lateResponse; // was the response given in time
        let earlyResponse; // was the response given too early
        let repeat; // check if the current trial should be repeated or not

        // parameters for user control
        let orientation; // get the screen orientation (landscape or portrait)
        // check the screen
        if (typeof screen.orientation === 'undefined'){
            // alternative when orientation is not available
            // check if the device is wider than high
            orientation = [screen.innerHeight<screen.innerWidth, 'rel']
        } else {
            orientation = [screen.orientation.angle, 'angle']
        }

        // stimulus styles
        // stimuli dont get an ID here - the ID will be added in the custom java script
        let centralPoint = "<dot></dot>";
        let invisibleCentralPoint = "<dot style = 'background-color: rgba(153,31,35,0);'></dot>";
        let rightTar = "<dot style = 'right:calc(50% - 200px); margin-left:0; margin-right: -25px'></dot>";
        // invisible right tar
        let rightTarInvisible = "<dot style='right:calc(50% - 200px); width:300px; height:300px; " +
            "margin-top: -150px; margin-right: -150px; margin-left: 0;  background-color:rgba(56,153,53,0);'></dot>";
        let leftTar = "<dot style = 'left:calc(50% - 200px);'></dot>";
        // invisible left Tar
        let leftTarInvisible = "<dot style='left:calc(50% - 200px); width:300px; height:300px; " +
            "margin-top: -150px; margin-left: -150px; background-color:rgba(153,31,35,0);'></dot>";
        let rightTarShiftIn =  "<dot style = 'right:calc(50% - 150px); margin-left:0; margin-right: -25px'></dot>";
        let rightTarShiftOut =  "<dot style = 'right:calc(50% - 250px); margin-left:0; margin-right: -25px'></dot>";
        let leftTarShiftIn = "<dot style = 'left:calc(50% - 150px); '></dot>";
        let leftTarShiftOut = "<dot style = 'left:calc(50% - 250px);'></dot>";
        let flashUpVisible = "<div style = 'position:absolute; left:0; top:0; width:100%; height:calc(50% - 100px); background-color:rgba(255,255,255,1);-webkit-touch-callout: none; -webkit-user-select: none;'></div>";
        let flashDownVisible = "<div style = 'position:absolute; left:0; bottom:0; width:100%; height:calc(50% - 100px); background-color:rgba(255,255,255,1);-webkit-touch-callout: none; -webkit-user-select: none;'></div>";
        let flashUpInvisible = "<div style = 'position:absolute; left:0; top:0; width:100%; height:calc(50% - 100px); background-color:rgba(255,255,255,0);-webkit-touch-callout: none; -webkit-user-select: none;'></div>";
        let flashDownInvisible = "<div style = 'position:absolute; left:0; bottom:0; width:100%; height:calc(50% - 100px); background-color:rgba(255,255,255,0);-webkit-touch-callout: none; -webkit-user-select: none;'></div>";

        // set up variables for loop
        let nT; // number of trials
        let T; // trial
        let cF; // condition flash index
        let cJ; // condition jump index
        let cI; // condition inwards index
        let cP; // condition position index
        let fixT; // time for fixation
        let ID = 0; // trial ID initialization

        let flash_condition; // current flash condition
        let jump_condition; // current jump condition
        let inwards_condition; // current inwards condition
        let position_condition; // current position condition

        // loop through trials
        for (nT = 0; nT < nTrials; nT++){
            // loop through flash conditions
            for (cF = 0; cF < cFlash.length; cF++){
                flash_condition = cFlash[cF];
                // loop through jump conditions
                for (cJ = 0; cJ < cJump.length; cJ++){
                    jump_condition = cJump[cJ];
                    // loop through inwards conditions
                    for (cI = 0; cI < cInwards.length; cI++){
                        inwards_condition = cInwards[cI];
                        // loop though position conditions
                        for (cP = 0; cP < cPosition.length; cP++){
                            position_condition = cPosition[cP];
                            // assign all values to the current trial
                            T = {
                                sidePoint: function(){if (position_condition === 'r'){return rightTar} else{return leftTar}}(),
                                jumpedPoint: function(){if (position_condition === 'r'){if(inwards_condition){return rightTarShiftIn
                                } else {return rightTarShiftOut}
                                } else {if(inwards_condition){return leftTarShiftIn
                                } else {return leftTarShiftOut}
                                }
                                }(),
                                sideButton: function(){if (position_condition === 'r'){return rightTarInvisible} else{return leftTarInvisible}}(),
                                flashUp:function(){if (flash_condition){return flashUpVisible} else{return flashUpInvisible}}(),
                                flashDown: function(){if (flash_condition){return flashDownVisible} else{return flashDownInvisible}}(),
                                position: position_condition,
                                stimJumps: jump_condition,
                                inwards: inwards_condition,
                                showFlash: flash_condition,

                                fixTime: fixTime*Math.random(),
                                flashTime: flashTime*Math.random(),
                                trialDuration: trialDur,
                                trialID: ID,
                            };
                            // save the current trial in our design structure
                            test_stimuli.push(T);
                            // increase the ID by one
                            ID ++;
                        }
                    }
                }
            }
        }

        // first trial: ask user for permission to enter fullscreen
        let confirm_fullscreen = {
            type: "fullscreen",
            message:["<p>Click below to change to fullscreen mode.</p>"],
            fullscreen_mode: true,
            button_label: 'Fullscreen',
            data: {
                test_part: 'fullscreen_request',
            }
        };
        timeline.push(confirm_fullscreen);

        // core trial structure
        let trial = {
            type: 'manual-inhibition-jump', // calls the custom plugin
            centralPoint: centralPoint, // the central point is the same for all trials
            centralButton: invisibleCentralPoint, // the central button is the same for all trials
            sidePoint: jsPsych.timelineVariable('sidePoint'), // the side point is either left or right
            jumpedPoint: jsPsych.timelineVariable('jumpedPoint'), // the jumped point is either left or right and forwards or backwards
            sideButton: jsPsych.timelineVariable('sideButton'), // the side button is either left or right
            flashUp: jsPsych.timelineVariable('flashUp'), // the upper flash is either visible or invisible
            flashDown: jsPsych.timelineVariable('flashDown'), // the lower flash is either visible or invisible
            fixTime: jsPsych.timelineVariable('fixTime'), // the fixation time is a random value between 0 and 1000 ms
            flashTime: jsPsych.timelineVariable('flashTime'), // the flash time is a random value between 0 and 250 ms
            trialDuration: jsPsych.timelineVariable('trialDuration'), // the trial duration is 1000 ms after the first jump
            flashDuration: flashDur, // the flash is shown for 30 ms in each trial
            waitAfter: waitAfter, // the trial waits 500 ms before presenting feedback
            runTrial: function() {
                // this function defines on each trial if it should run or not
                // get the ID of the current trial
                let id_here = jsPsych.timelineVariable('trialID', true);
                // repeat_trials is empty till the first loop completed
                if (repeat_trials.length > 0) {
                    // check if the current trial ID was included in the repetition list
                    repeat = repeat_trials.includes(id_here);
                } else {
                    // if the repetition list is empty, we are in the first loop and run every trial
                    repeat =  true;
                }
                return repeat;
                },

            // save the data from the current trial
            data: {
                test_part: 'trial',
                position: jsPsych.timelineVariable('position'),
                stimJumped: jsPsych.timelineVariable('stimJumps'),
                flashShown: jsPsych.timelineVariable('showFlash'),
                inwards: jsPsych.timelineVariable('inwards'),
                fixTime: jsPsych.timelineVariable('fixTime'),
                flashTime: jsPsych.timelineVariable('flashTime'),
                trialDuration: jsPsych.timelineVariable('trialDuration'),
                trialID: jsPsych.timelineVariable('trialID'),
            },
            // this function is executed after each trial
            on_finish: function (data){
                // check if the response was given too early
                earlyResponse = data.earlyResponse;
                // check if the response was given too late
                lateResponse = data.lateResponse;
                // save a repetition value for the feedback trial
                repeat = data.trialShown;

                // if the response was early or late and the trial was presented in the firs place,
                // save the ID of the trial
                if (data.trialShown){
                    if (lateResponse || earlyResponse){
                    T = jsPsych.timelineVariable("trialID", true);
                    repeat_IDs.push(T);
                    }
                }
            },
        };

        // feedback displayed after every trial
        let feedback = {
            type: 'html-button-response-conditional',
            stimulus: function () {
                // evaluate the last trial, and adjust the stimulus that will be returned
                if (earlyResponse) {
                    return "<p>Please keep you finger at fixation till the point jumps!</p>"
                } else if (lateResponse) {
                    return "<p>Too slow!</p>"
                } else {
                    return "<p>Well Done.</p>"
                }
            },
            post_trial_gap: 0, // needs to be zero to avoid waiting times when the trial is skipped
            choices: [''], // don't display choices
            button_html: '', // don't display buttons
            trial_duration: 1500, // display the feedback for 1500 ms
            runTrial: function(){return repeat}, // evaluate if the trial should run or not
            data:{
                test_part: 'feedback',
            },
        };
        
        // define a training procedure
        let test_procedure = {
            timeline: [trial, feedback], // one trial and one feedback will be repeated after each other
            timeline_variables: test_stimuli, // our design structure provides the timeline variables
            repetitions: 1, // our design structure is repeated once
            randomize_order: true, // the order of trials is random
            // this function evaluates if we want to repeat the loop
            // if it evaluates to true, we repeat the full design matrix
            loop_function: function(){
                // save the IDs to be repeated in a new variable
                repeat_trials = repeat_IDs;
                // check if there are any IDs to repeat
                let eval_loop = repeat_IDs.length > 0;
                // reset the repetition array to empty
                repeat_IDs = [];
                // return true or false
                return eval_loop
            },
        };
        timeline.push(test_procedure);

        /* start the experiment */
        // load jatos - I can use jatos functions after this line
        jatos.onLoad(function () {

            jsPsych.data.addProperties({
                subject: jatos.workerId, // id of the subject
                screenWidth: screen.width, // screen Width in px
                screenHeight: screen.height, // screen Height in px
                userInfo: navigator.userAgent, // some information about the user device
                platform: navigator.platform, // some information about the web browser
                scrPixDepth: screen.pixelDepth, // some information about the pixel structure
                scrColDepth : screen.colorDepth, // some information about the color channels
                scrOrientation: orientation, // save the orientation information
                scrResolution: window.devicePixelRatio, // save the pixel ratio
                component: 'Trials_Jump', // name the component
            });

            jsPsych.init({
                timeline: timeline, // use the timeline to run the experiment
                fullscreen: true, // run in fullscreen if possible
                on_finish: function() {
                    // once the code has run: save the results and call the next jatos component
                    let resultJson = jsPsych.data.get().json();
                    jatos.submitResultData(resultJson, jatos.startNextComponent);
                },
            });
        });
    </script>
</body>


</html>