<!DOCTYPE html>

<html lang="en">

<head>
  <title>Experiment Block Serial Dots</title>
  <script src="jspsych-6.0.4/jspsych.js"></script>
  <script src="jspsych-6.0.4/plugins/jspsych-instructions.js"></script>
  <script src="jspsych-6.0.4/plugins/jspsych-fullscreen.js"></script>
  <!-- custom scripts -->
  <script src="jspsych-6.0.4/plugins/custom-manual-inhibition-serial-Laura.js"></script>
  <script src="jspsych-6.0.4/plugins/custom-html-button-response-conditional.js"></script>

  <script src="jspsych-6.0.4/plugins/jspsych-html-button-response.js"></script>  
  
  <link href="styles.css" rel="stylesheet" type="text/css">
  <script src="objects.js"></script>
  <script type= "text/javascript" src="loops.js"></script>
  <script src="common_vars.js"></script>
  <!-- jatos import -->
  <script src="jatos.js"></script>
  <!-- css import -->
  <link rel="stylesheet" type="text/css" href="jspsych-6.0.4/css/jspsych.css">
    <!-- use the line bleo to prevent user scaling and marking -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>

  <body bgcolor='gray'>
    <script>

      // salute the hacker
      console.log('42');


      let stop = false;

    
      let timeControl = 0

      let startTime;
      let endTime;
      let durationTime;


      


      // define parameter values for the experiment
      let nTrials = 10; // number of trials per condition
      let trialDuration = 1500; // duration of the trial
      // for this design, we will create n even time windows between 0 up to the duration of the experiment.
      // we will sample nTrials random trials in each of these time windows.
      // This ensures a random distribution that samples across the entire range from 0 up to the trial duration
      // and avoids clusters appearing by chance.
      let maxFlashTime = trialDuration; // maximum time after which a flash is shown in ms
      let twSize = 100; // the size of the time windows
      let flashDuration = 30; // how long the flash will be on the screen in ms
      let waitAfter = 500; // how long we will wait at the end of the trial in ms

      

      let timelineVariables = Serial_loop(nTrials, maxFlashTime, twSize);
      
      // define the main trial for the experiment
      let trial = {
        type: 'manual-inhibition-serial', // calls the custom plugin


        buttonsVisible: visibleButtons, // the visible buttons are an array of dots
        buttonsInvisible: invisibleButtons, // the invisible buttons are an array of dots
        flashUp: flashUpVisible, // the upper part of the white flash
        flashDown:flashDownVisible, // the lower part of the white flash
        flashTime: jsPsych.timelineVariable('flashTime'), // the time when the flash appears between 0 ms and the trial duration
        flashDuration: flashDuration, // the time the flash is visible in ms
        trialDuration: trialDuration, // the trial duration after the first point was touched
        waitAfter: waitAfter, // how long to wait after the trial ended

        on_load: function(){

          if (stop){
            
            for (var i = 0; i < trial.buttonsInvisible.length; i++) {
                  document.querySelector('#invisible-button-' + i).style.visibility = "hidden";
              };

          };
          // Window with exceded time and do you still want to submit data? Also set a specific time limit for the training, include in all parts 
          // 15 min for instructions 

    
        },

       

        runTrial: function() {
          // in this function, we define if we want to run this trial or not
          // get the id of the current trial
                let id_here = jsPsych.timelineVariable('trialID', true);
                // if there are any values in the repeat trial array
                if (repeat_trials.length > 0) {
                  // run the trial if the value is inside the array
                  repeat = repeat_trials.includes(id_here);
                } else {
                  // this is the first round, we run every trial
                  repeat = true;
                }
                return repeat;
                },
        data:{
          // assign relevant data
          test_part: 'Serial-Inhibition', // the part of the experiment
          flashTime: jsPsych.timelineVariable('flashTime'),  // the time when a flash was shown
          trialID: jsPsych.timelineVariable('trialID'), // the id of the trial

        },
        on_finish:  function(data){
          // evaluate if the there were any mistakes and if the trial need repetition
          orderResponse = data.orderResponse; // were the answers given in order
          lateResponse = data.lateResponse; // was the response fast enough

          jatos.studySessionData.totalWaitTime += data.waitTime

          console.log('Total Wait Time');
          console.log(jatos.studySessionData.totalWaitTime);
          

          if (jatos.studySessionData.totalWaitTime  >= jatos.studySessionData.allowedWaitTime){

            stop = true;

            console.log("You exceded max time");

            };
        

          // if out of order or late response, create new T object and push it to repeat_IDs
          if (data.trialShown) {
            // evaluate only for trials that were shown
            if (lateResponse || !orderResponse) {
              // if there was any error
              // get the trial ID
              T = jsPsych.timelineVariable("trialID", true);
              // and save it
              repeat_IDs.push(T);
            }
          }
        },
      };


  
 

      // display feedback
      let feedback = {
        type: 'html-button-response-conditional',
        trialID: jsPsych.timelineVariable('trialID'),
        stimulus: function () {
          // evaluate which feedback should be shown
          if (lateResponse){
            return "<p>Too slow</p>"
          }else if (orderResponse) {
            return "<p>Well Done.</p>"
          } else {
            return "<p>Please follow the order.</p>"
          }
        },
        post_trial_gap: 0, // needs to be zero to avoid waiting times when the trial is skipped
        choices: [''], // don't display choices
        button_html: '', // don't display buttons
        trial_duration: 1500, // display the feedback for 1500 ms
        runTrial: function(){return repeat}, // evaluate if the trial should run or not
        data:{
            test_part: 'feedback',
        },
      };

    // define a training procedure
    let test_procedure = {
      timeline: [trial, feedback], // one trial and one feedback will be repeated after each other
      timeline_variables: timelineVariables, // our design structure provides the timeline variables
      repetitions: 1, // our design structure is repeated once
      randomize_order: true, // our design structure will be repeated in a random order
      // this function evaluates if we want to repeat the loop
      // if it evaluates to true, we repeat the full design matrix
      loop_function: function(){
          // save the IDs to be repeated in a new variable
          repeat_trials = repeat_IDs;
          // check if there are any IDs to repeat
          let eval_loop = repeat_IDs.length > 0;
          // reset the repetition array to empty
          repeat_IDs = [];
          // return true or false
          return eval_loop
      },
    };
    timeline.push(test_procedure);

    /* start the experiment */
    // load jatos - I can use jatos functions after this line
    jatos.onLoad(function () {

    

      jsPsych.data.addProperties({
        subject: jatos.workerId, // id of the subject
        screenWidth: screen.width, // screen Width in px
        screenHeight: screen.height, // screen Height in px
        userInfo: navigator.userAgent, // some information about the user device
        platform: navigator.platform, // some information about the web browser
        scrPixDepth: screen.pixelDepth, // some information about the pixel structure
        scrColDepth : screen.colorDepth, // some information about the color channels
        scrOrientation: ori, // save the orientation information
        scrResolution: window.devicePixelRatio, // save the pixel ratio
        component: 'Inhibition_Serial', // name the component
      });

      jsPsych.init({
          timeline: timeline, // use the timeline to run the experiment
          fullscreen: true, // run in fullscreen if possible
          on_finish: function() {
            // once the code has run: save the results and call the next jatos component
            let resultJson = jsPsych.data.get().json();
            jatos.submitResultData(resultJson, jatos.startNextComponent);
          }
      });
  });
    </script>
  </body>
</html>
